Bug-1: SHA512-UnclearedValid
User noticable symptom: Software finds an error indicator in the firmware is set to 1.
Debugging procedure:
Q1: What's the state of the circuit when the 8-packet rule is violated?
I1: state transition, condition of almfull violation (an experienced developer can already find the bug here)
Q2: Why is the valid bit always 1 when the circuit is in that state?
I2: valid bit, almfull signal (now the bug is obvious)

Bug-2: SHA512-BitTruncation
User noticable symptom: IOMMU page fault reported by FPGA driver; the memory channel of the FPGA is blocked.
Debugging procedure:
Q1: What's the state of the circuit when the error bit is set to 1? (there's an error bit in the FPGA interface) What's the faulted address?
I1: state variable, error bit, address of each read and write channel (the developer would find the address of the memory transaction is not expected, an experienced developer can already locate the bug)
Q2: What's the address value the FPGA receives (via MMIO write)?
I2: mmio write valid bit, mmio value

Bug-3: SSSP-OutdatedValid
User noticable symptom: the result of the SSSP is wrong
Debugging procedure:
Q1: Does the core SSSP algorithm implementation receives vertices and edges correctly?
I1: control signal of SSSP, input valid of SSSP (after collecting these data, the developer will know that an edge is treated as vertices)
Q2: Where does the edge become a vertex?
I2: state transition, count of vertices, count of edges, count of total packets

Bug-4: RSD-BufferOverflow-Variation-1
User noticable symptom: the acceleration task never finishes
Debugging procedure:
Q1: What's the value of the state variable when the execution stucks?
I1: read state machine, write state machine (developers would find out the state is "waiting write response", which means there're no enough requests issued)
Q2: How many packets does the FPGA receive? How many packets does the RSD core receive? How many output does the RSD core generate? How many output does the FPGA issue? (trying to localizing the lost)
I2: packet counters at different locations (we now know something is lost in the write combining buffer; an experienced developer may notice the overflow may relates to almfull)
Q3: What's the index of the write combining buffer on each write, and when does read occurs?
I3: the write index of the write combining buffer, the read valid signal (now we know the buffer was overwritten before sending out)
Q4: Why doesn't the FPGA sends out the buffer before an overwrite occurs? (for confirmation)
I4: almost full

Bug-4: RSD-BufferOverflow-Variation-2
User noticable symptom: a small portion of the computation result is wrong; the first few bytes of the problematic cacheline is the same as the next cacheline
Debugging procedure:
Q1: Obviously this is an overflow in the write combining buffer. So developers can directly ask Q3 in the previous variation.
I1: the write index of the write combining buffer, the read valid signal

Bug-5: Grayscale-BufferOverflow
User noticable symptom: the acceleration task never finishes
Debugging procedure:
Q1: What's the value of the state variable when the execution stucks?
I1: read state machine, write state machine (developers would find out the state is "waiting write response", which means there're no enough requests issued)
Q2: How many packets does the FPGA receive? How many packets does the grayscale core receive? How many output does the grayscale core generate? How many output does the FPGA issue? (trying to localizing the lost)
I2: packet counters at different locations
Q3: Will the fifo overflow? Why will there be an overflow?
I3: fifo overflow indicator, used fifo entries, almfull

Bug-6: Optimus-BufferOverflow
User noticable symptom: the acceleration task never finishes
Debugging procedure:
Q1: What's the state of the accelerator?
I1: read and write state machine (developers would find that the read never finished)
Q2: How many read requests does the accelerator issues and how many read responses does the accelerator receives?
I2: counter of accelerator-issued read requests and accelerator-received read responses, counter of hypervisor-issued/-received read requests and response (developers would find that it's a hypervisor problem and a read request is lost in the hypervisor)
Q3: What's the more detailed location of the request loss?
I3: read request counter in different locations in the hypervisor (now we can localize the loss to somewhere around the sidebuf)
Q4: Is there a problem with the sidebuf?
I4: read and write index of the sidebuf (we will find the overflow)

Bug-7: Optimus-SignalConflict
User noticable symptom: the acceleration task never finishes
Debugging procedure:
Q1-Q3: same as Bug-6, after Q3, unlike Bug-6, we find that packets keep flowing into the sidebuf module while the sidebuf is being read; as a result, we can find the signal SignalConflict

Bug-8, Bug-9, Bug-10 can be detected during simultion.

Bug-11: AXI-Lite-DropAck
User noticable symptom: when debugging a complex circuit using this IP, the developer notices that this IP does not give enough acks
Debugging procedure:
Q1: What's the valid/ready/ack bits?
I1: all the valid/ready/ack bits

Bug-12: AXI-Stream-IncorrectLast
User noticable symptom: when debugging a comple circuit using this IP, the developer notices that the tail of data transmission k is incorrectly appended to the head of data transission k+1.
Debugging procedure:
Q1: What's the control signals of the AXI channel?
I1: all valid/ready/last bits

